import Foundation

class VM {
    
    var memory = [Int](repeating: 0, count: 2000)
    var registers = [Int](repeating: 0, count: 10)
    
    var currentIndex : Int
    var currentInstruction : Instruction
    var lastCmpr = 0
    
    enum Instruction: Int {
        case halt, clrr, clrx, clrm, clrb, movir, movrr, movrm, movmr, movxr, movar, movb, addir, addrr, addmr, addxr, subir, subrr, submr, subxr, mulir, mulrr, mulmr, mulxr, divir, divrr, divmr, divxr, jmp, sojz, sojnz, aojz, aojnz, cmpir, cmprr, cmpmr, jmpn, jmpz, jmpp, jsr, ret, push, pop, stackc, outci, outcr, outcx, outcb, readi, printi, readc, readln, brk, movrx, movxx, outs, nop, jmpne
    }
    
    var textToPrint = ""
    
    init(input: [Int]) {
        
        if input[0] > 2000 {
            memory = [Int](repeating: 0, count: input[0] + 100)
        }
        for i in 0..<input.count - 2 {
            memory[i] = input[i + 2]
        }
        
        currentIndex = input[1]
        currentInstruction = Instruction(rawValue: memory[currentIndex])!
    }
    
    func run() {
        while currentInstruction != Instruction.halt {
            executeInstruction()
            print(registers)
            currentInstruction = Instruction(rawValue: memory[currentIndex])!
        }
        print(registers)
        print(memory)
        print(textToPrint)
    }
    
    func parameter(_ parameterNumber: Int) -> Int {
        return memory[currentIndex + parameterNumber]
    }
    
    func executeInstruction() {
        print(currentInstruction)
        switch currentInstruction {
        case .clrr:
            registers[parameter(1)] = 0
            currentIndex += 2
        case .clrx:
            memory[registers[parameter(1)]] = 0
            currentIndex += 2
        case .clrm:
            memory[parameter(1)] = 0
            currentIndex += 2
        case .clrb:
            let start = registers[parameter(1)]
            let count = registers[parameter(2)]
            for i in start..<start + count {
            memory[i] = 0
            }
            currentIndex += 3
        case .movir:
            registers[parameter(2)] = parameter(1)
            currentIndex += 3
        case .movrr:
            registers[parameter(2)] = registers[parameter(1)]
            currentIndex += 3
        case .movrm:
            memory[parameter(2)] = registers[parameter(1)]
            currentIndex += 3 
        case .movmr:
            registers[parameter(2)] = memory[parameter(1)]
            currentIndex += 3
        case .movxr: print("Nothing yet!")
        case .movar: print("Nothing yet!")
        case .movb:
            let source = registers[parameter(1)]
            let destination = registers[parameter(2)]
            let count = registers[parameter(3)]
            for i in 0..<count {
                memory[destination + i] = memory[source + i]
            }
            currentIndex += 4
        case .addir:
            registers[parameter(2)] += parameter(1)
            currentIndex += 3
        case .addrr:
            registers[parameter(2)] += registers[parameter(1)]
            currentIndex += 3
        case .addmr:
            registers[parameter(2)] = memory[parameter(1)]
            currentIndex += 3
        case .addxr: print("Nothing yet!")
        case .subir: print("Nothing yet!")
        case .subrr: print("Nothing yet!")
        case .submr: print("Nothing yet!")
        case .mulir: print("Nothing yet!")
        case .mulxr: print("Nothing yet!")
        case .divir: print("Nothing yet!")
        case .divrr: print("Nothing yet!")
        case .divxr: print("Nothing yet!")
        case .jmp: print("Nothing yet!")
        case .sojz: print("Nothing yet!")
        case .sojnz: print("Nothing yet!")
        case .aojz: print("Nothing yet!")
        case .aojnz: print("Nothing yet!")
        case .cmpir: print("Nothing yet!")
        case .cmprr:
            lastCmpr = registers[parameter(1)] - registers[parameter(2)]
            currentIndex += 3
        case .cmpmr: print("Nothing yet!")
        case .jmpn: print("Nothing yet!")
        case .jmpz: print("Nothing yet!")
        case .jmpp: print("Nothing yet!")
        case .jsr: print("Nothing yet!")
        case .ret: print("Nothing yet!")
        case .push: print("Nothing yet!")
        case .pop: print("Nothing yet!")
        case .stackc: print("Nothing yet!")
        case .outci: print("Nothing yet!")
        case .outcx: print("Nothing yet!")
        case .outcr:
            textToPrint += String(AsciiToChar(registers[parameter(1)]))
            currentIndex += 2
        case .outcb: print("Nothing yet!")
        case .readi: print("Nothing yet!")
        case .printi:
            textToPrint += String(registers[parameter(1)])
            currentIndex += 2
        case .readc: print("Nothing yet!")
        case .readln: print("Nothing yet!")
        case .brk: print("Nothing yet!")
        case .movrx: print("Nothing yet!")
        case .movxx: print("Nothing yet!")
        case .outs:
            let stringLength = memory[parameter(1)]
            let stringStart = parameter(1) + 1
            let stringEnd = stringStart + stringLength
            for i in stringStart..<stringEnd {
                textToPrint += String(AsciiToChar(memory[i]))
            }
            currentIndex += 2
        case .nop: print("Nothing yet!")
        case .jmpne:
            if lastCmpr != 0 {
                currentIndex = parameter(1)
            } else {
                currentIndex += 2
            }
        default: print("Instruction not recognized")
        }
    }
}
